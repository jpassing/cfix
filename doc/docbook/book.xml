<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book >
  <title>cfix</title>

  <bookinfo>
    <releaseinfo>Release 1.0</releaseinfo>
    <author>Johannes Passing</author>
  </bookinfo>

  <toc/>
  
  <chapter id="Documentation">
	<title>Documentation</title>
	<section id="Introduction">
		<title>Introduction</title>
		<para>
		cfix is a framework for authoring and running xUnit-like testcases written in C or C++. The aim of the tool
		is to provide a development experience very similar to frameworks such as JUnit or NUnit. Due to the nature of
		C and C++, current unit testing	frameworks for C and C++ hardly reach the ease of use of JUnit or NUnit. In 
		particular, it is noticable that significantly more code has to be written to implement a test suite. 
		</para>
		<para>
		Languages like Java and the various .Net languages, as well as scripting languages, all provide reflection facilities.
		Unit testing frameworks for these languages can therefore rely on reflective features in order to minimize the amount
		of code required to define a test suite. Provided a library, the framework can find and identify test cases and is able to selectively run them.
		</para>
		<para>
		Lacking similar reflective facilities, the route most unit testing frameworks for C and C++ have 
		chosen is to oblige the developer to explicitly define test cases and fixtures. Taking CUnit as an example,
		the developer has to make explictit function calls to define a test suite, add test cases to the suite and to 
		finally run this suite. CppUnit simplifies this a bit, but still requires the developer to implement quite
		some amount of initialization code. Another important drawback of this approach is the fact that no real
		separation between test code and test runner is done. Often, even the choice whether to use a graphical or a console frontend for 
		running test is tied to this initialization code.
		</para>
		<para>
		Based on this observation, it is clearly desirable to minimize the amount of boilerplate code the developer 
		has to write. Furthermore, a separation (in terms of artifacts, i.e. binaries) between the code to be tested
		and the test runner application is crucial.
		</para>
	</section>
	<section id="Portability">
		<title>Portability</title>
		<para>
		Most current unit testing frameworks for C and C++ are portable. The same tools can be used to test code on a multitude of
		platforms. Although a sound feature, several compromises have to be made to allow portability of both tools and test suites.
		As such, forgoing non-portable operating system features contributes to the fact that these frameworks are significantly
		less convenient to use than their managed counterparts NUnit or JUnit.
		</para>
		<para>
		For a vast amount of projects, portability is not actually required - a significant amount of software developed 
		today is targeted at a single platform only. Striving to provide a powerful, yet easy to use testing framework, the approach
		chosen by cfix is thus to sacrifice portability in order to gain the option to fully exploit the services provided
		by the Windows platform. These services at hand, cfix is thus able to provide the features expressed in the previous section -
		minimizing the amount of code a developer has to write and providing a strict separation in terms of artifacts 
		between test code and test runner.
		</para>
	</section>
	<section>
		<title>Terms used</title>
		<para>
		The following terms are used throughout this documentation.
		</para>
		<section>
			<title>Test Case</title>
			<para>
				A Test Case<indexterm><primary>Test Case</primary></indexterm> contains the actual testing code. It utilizes assertions etc. to report
				success or failure of certain operations. A test case is implemented as a single routine.
			</para>
			<para>
				This understanding corresponds to test methods (i.e. methods decorated with [Test]) in NUnit.
			</para>
		</section>
		<section>
			<title>Test Fixture</title>
			<para>
				A Test Fixture<indexterm><primary>Test Fixture</primary></indexterm> is a collection of test cases, accompanied by a setup and teardown routine.
			</para>
			<para>
				This understanding corresponds to test classes (i.e. classes decorated with [TestFixture]) in NUnit.
			</para>
		</section>
		<section>
			<title>Test Module</title>
			<para>
				All fixtures are compiled and linked into a single binary, which is a DLL file. This DLL file
				is referred to as Test Module<indexterm><primary>Test Module</primary></indexterm>.
			</para>
		</section>
		<section>
			<title>Test Suite</title>
			<para>
				A collection of one or more test modules is referred to as test suite.
			</para>
		</section>
	</section>
	<section>
		<title>Tool strategy</title>
		<para>
		As indicated in the <link linkend="Introduction">Introduction</link>, cfix implements a separation between
		test code, which is provided in form of a test module, and the test runner, which is provided by cfix. This
		separation is similar to NUnit and JUnit, but differs significantly from the approach chosen by CUnit and CppUnit.
		</para>
		
		<para>
		All test cases and fixtures are compiled and linked into a simgle DLL, the test module. The test runner, named
		cfix32.exe (or cfix64.exe for AMD64 platfowms), can now be used to run all or a selection of test fixtures.
		The way cfix implements this introspection of a test module is to rely on the features of the PE file format
		used by Windows. By inspecting the export directory of the PE file, all fixtures defined in a test module can
		be identified. Depending on user input, cfix can then selectively run these fixtures. This approach is similar to WinUnit,
		although the exact implementation differs.
		</para>
	</section>
	<section>
		<title>Test Run<indexterm><primary>Test Run</primary></indexterm></title>
		<para>
		Provided one or more test modules, cfix can be requested to run certain fixtures<indexterm><primary>Fixture</primary></indexterm>. Fixtures
		are exeuted in the following sequence:
		
		<itemizedlist>
		<listitem>
			<para>
			First, the setup routine<indexterm><primary>Setup Routine</primary></indexterm> (if one has been provided) is run. In case
			an assertion fails or an unhandled exception is thrown from within the setup routine, the routine is aborted. As the 
			setup routine is considered to play a vital role for successful execution of a fixture, the entire fixture
			is aborted as well.
			</para>
		</listitem>
		<listitem>
			<para>
			Next, the test cases of the fixture are run one after another. In case of failed assertions or unhandled exceptions, the
			test case is immediately aborted and execution is resumed at the next test case.
			</para>
		</listitem>
		<listitem>
			<para>
			Finally, after all test cases have completed, the teardown routine is run. Teardown routines, like setup routines,
			are optional, so this step does not apply to all fixtures. Again, failed assertions and unhandled exceptions
			lead to the abortion of the routine.
			</para>
		</listitem>
		</itemizedlist>
		
		<note>
		Fixtures are always run	in its entirety -- it is not possible to run a single test case only.
		</note>
		
		What exactly does abortion of a routine mean? All failures are first reported so that the user is informed about the
		situation. By using Windows Structured Exception Handling, cfix then causes the affected routine to be aborted, i.e.
		no further statements of the routine are executed. 
		</para>
		<para>
		It is notable that the exact behaviour in the event of a failure differs on the context. As such, cfix is aware
		of the presence of a debugger and adapts its behaviour appropriately. As an example, if a debugger is present and an
		assertion fails, the test case is not aborted -- instead a brealpoint is issued so that the debugger breaks in
		on the affected line of code.
		</para>
		<para>
		Moreover, by specifying appropriate command line options, the behaviour can be further adjusted. This includes changing the way
		cfix deals with unhandled exceptions or specifying that the test run should be aborted as soon as the first failure
		occurs.
		</para>
		<para>
		As indicated before, all events -- be it the successful completion of a test case, failed assertions, log messages or 
		unhandled exceptions are reported. Depending on the options chosen by the user, the information
		is displayed on the console or logged to a text file.
		</para>
	</section>
	<section>
		<title>Multithreading<indexterm><primary>Multithreading</primary></indexterm></title>
		<para>
		cfix has been implemented in a threadsafe manner. Furthermore, test cases are explicily allowed to make use
		of multithreading as long as they use the wrapper function CfixCreateThread rather than CreateThread.
		</para>
		<para>
		The motivation behind this is as follows. Although the current release supports execution of one fixture
		at a time only, future releases are planned to allow parallel test execution. While the details are not of
		importance at this stage, it already raises the question of how to deal with unknown threads, i.e. threads that
		have been created by test cases and are thus outside of cfix' control. In order to relate such threads
		to the test case they belong to, cfix needs some help -- and this help comes in the form of using
		the CfixCreateThread wrapper function. cfix will relate a thread created by CfixCreateThread with the 
		existing test case and is now also able to handle any events (assertions etc) by this thread properly.
		
		<note>
			When creating threads from within a test case and these threads use the cfix API (CFIX_ASSERT, CFIX_LOG etc), always
			make sure to use CfixCreateThread rather than CreateThread. Threads not using the cfix API (worker threads etc)
			are not affected by this requirement.
		</note>
		</para>
	</section>
  </chapter>
  
  <chapter id="Tutorial">
    <title>Tutorial</title>
	<section>
		<title>Installing cfix</title>
		<para>
		After downloading and unpacking the cfix distribution, you will see the following folder structure:
		<figure><title>Folder Structure<indexterm><primary>Folder Structure</primary></indexterm></title>
			<graphic fileref="tut_foldstruct.gif">
			</graphic>
		</figure>
		The bin folder contains the binaries, the ones of interest are cfix32<indexterm><primary>cfix32</primary></indexterm> 
		and cfix64<indexterm><primary>cfix64</primary></indexterm>. The binaries contain their
		bit-ness in their name so that you can put both the i386 and the amd64 folder in your 
		PATH<indexterm><primary>PATH</primary></indexterm> without getting
		conflicts. The remaining folders should be self-explanatory.
		</para>
		<para>
		The tutorial assumes that you plan to write tests with Visual Studio<indexterm><primary>Visual Studio</primary></indexterm>. 
		In this case, it is advisable to first configure
		Visual Studio so that it automatically finds the required cfix files. The following paragraphs explain how.
		</para>
		<para>
		Start Visual Studio and open the Options dialog<indexterm><primary>Options Dialog</primary></indexterm> (Tools | Options). 
		In the tree view on the left, navigate to
		'Projects and Solutions' and finally 'C++ Directories'<indexterm><primary>C++ Directories</primary></indexterm>. There, 
		add the appropriate cfix binary directories (bin\i386 for platform 'Win32', bin\amd64 for platform 'x64').
		<figure><title>Configuring Exe Directories</title>
			<graphic fileref="tut_vs_opt_exe.gif">
			</graphic>
		</figure>
		
		Now, select 'Include files'<indexterm><primary>Include files</primary></indexterm> in the dropdown menu on the 
		top right and add the cfix include directory to the list.
		<figure><title>Configuring Include Directories</title>
			<graphic fileref="tut_vs_opt_inc.gif">
			</graphic>
		</figure>
		
		And finally, select 'Library files'<indexterm><primary>Library files</primary></indexterm> in the dropdown menu on the top right 
		and add add the appropriate 
		cfix library directories (lib\i386 for platform 'Win32', lib\amd64 for platform 'x64').
		<figure><title>Configuring Library Directories</title>
			<graphic fileref="tut_vs_opt_lib.gif">
			</graphic>
		</figure>
		
		That is all, we are ready to write our first test project.
		</para>
	</section>
	<section>
		<title>Authoring a test suite</title>
		<para>
		Test Modules are DLLs, so we need to create a new DLL project. In the 'New Project' Wizard, select 
		'Win32 Project'. On the following page, choose 'DLL' as application type.
		<figure><title>Creating a new Project</title>
			<graphic fileref="tut_vs_newproj.png">
			</graphic>
		</figure>
		</para>
		<para>
		A minimalistic test project could consist of the following code:
		<programlisting>
#include "stdafx.h"
#include &lt;cfix.h&gt;

/*++
	Routine Description:
		Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
	int a = 1;
	int b = 1;
	CFIX_ASSERT( a + b == 2 );
}

CFIX_BEGIN_FIXTURE( MyMinimalisticFixture )
	CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
		</para>
		<para>
		But let us look at a more interesting example. Open a source file and copy the following code:
			<programlisting>
//
// Always include cfix.h!
//
#include "stdafx.h"
#include &lt;cfix.h&gt;

/*++
  Routine Description:
    Setup Routine -- will be called at the very beginning of the
    testrun. If the setup routine fails, no testcase of this 
    fixture will be executed.

    If your default calling convention is cdecl (this is the 
    case for Visual Studio projects), be sure to add __stdcall 
    to all routine decarations -- otheriwse you will get the 
    following warning:
       cannot convert from 'void (__cdecl *)(void)' 
       to 'CFIX_PE_TESTCASE_ROUTINE'

    As the routine is referenced only by the fixture definition 
    (see below), you may declare this routine as static.
--*/
static void __stdcall FixtureSetup()
{
  CFIX_ASSERT( 0 != 1 );
}

/*++
  Routine Description:
    Teardown Routine -- will be called at the end of the
    testrun. 
--*/
static void __stdcall FixtureTeardown()
{
  CFIX_LOG( L"Tearing down..." );
}

/*++
  Routine Description:
    Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
  DWORD a = 1;
  DWORD b = 1;
  CFIX_ASSERT_EQUALS_DWORD( a, b );
  CFIX_ASSERT( a + b == 2 );

  //
  // Log a message -- printf-style formatting may be used.
  //
  CFIX_LOG( L"a=%d, b=%d", a, b );
}

/*++
  Routine Description:
    Another test routine -- one that will trigger a failed 
    assertion.
--*/
static void __stdcall Test2()
{
  DWORD a = 17;

  //
  // This one will fail. If run in the debugger, it will break here.
  // if run outside the debugger, the failure will be logged and the
  // testcase is aborted.
  //
  CFIX_ASSERT( a == 42 );
}

/*++
  Description:
    These lines define a test fixture. It is best to put this at the
    end of the file.

    'MyFixture' is the name of the fixture. It must be unique across
    all fixtures of this DLL. The same restrictions as for naming
    routines apply, i.e. no spaces, no special characters etc.

    The order of CFIX_FIXTURE_ENTRY, CFIX_FIXTURE_SETUP and 
    CFIX_FIXTURE_TEARDOWN is irrelevant. For the current release, 
    however, (1.0), the order of FIXTURE_ENTRYs defines the 
    execution order.
--*/
CFIX_BEGIN_FIXTURE( MyFixture )
  //
  // Define Test1 and Test2 to be test routines. You can define any 
  // number of test routines.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
  CFIX_FIXTURE_ENTRY( Test2 )

  //
  // Define FixtureSetup to be a setup routine. At most one
  // CFIX_FIXTURE_SETUP line may be declared per fixture.  If the
  // fixture does not require setup, omit this line.
  //
  CFIX_FIXTURE_SETUP( FixtureSetup )

  //
  // Define FixtureTeardown to be a teardown routine. As with
  // setup routines, you can declare at most one such routine
  // per fixture. If the fixture does not require teardown, 
  // omit this line.
  //
  CFIX_FIXTURE_TEARDOWN( FixtureTeardown )
CFIX_END_FIXTURE()

CFIX_BEGIN_FIXTURE( MyOtherFixture )
  //
  // You are free to reuse certain routines in another fixture if
  // it makes sense.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
			In order to run the code in the debugger, we have to make some adaptions to the project configuration
			<indexterm><primary>Project Configuration</primary></indexterm>.
			Open the project's property page and navigate to the 'Debugging'<indexterm><primary>Debugging</primary></indexterm> node. There, add
			'cfix32.exe' (or 'cfix64.exe' for the x64 configuration) as Command<indexterm><primary>Command</primary></indexterm>. Of course, this
			requires that you have previously set up the directories in the options dialog, 
			as described previously. (And do not omit the .exe suffix -- otherwise running without
			debugger will not work).
			<figure><title>Adjusting Debugging Settings</title>
				<graphic fileref="tut_vs_projsettings.png"></graphic>
			</figure>
		</para>
		<para>
			As Command Arguments<indexterm><primary>Command Arguments</primary></indexterm>, type '-u $(OutDir)\$(ProjectName).dll'.
			I have used the -u switch in order to break on exceptions. This makes debugging easier, so
			it is advisable to always use this switch for debugging.
			<note>When using C++<indexterm><primary>C++</primary></indexterm>, you shoud use the compiler switch
			/EHa<indexterm><primary>/EHa</primary></indexterm> rather than /EHs<indexterm><primary>/EHs</primary></indexterm>. 
			cfix internally uses SEH<indexterm><primary>SEH</primary></indexterm> and using
			/EHa ensures that your destructors are called properly in case a test case is aborted.
			</note>
		</para>
	</section>
	<section>
		<title>Running the test</title>
		<para>
			Hit F5 to compile the project and launch the test. Soon after the tesrun has started, you should see the following
			dialog indicating that a breakpoint<indexterm><primary>Breakpoint</primary></indexterm> has been hit:
			<figure><title>Failed Assertion</title>
				<graphic fileref="tut_vs_break.gif"></graphic>
			</figure>
			Click 'break' and you will see that the current the statement CFIX_ASSERT( a == 42 ) has fired --
			which is not surprising as a has the value 17. Now open the output window (Ctrl+Alt+O) and you should
			see the following output:
			<figure><title>Output Window</title>
				<graphic fileref="tut_run_dbg.png"></graphic>
			</figure>
			If you want to ignore this assertion, hit F5 and the fixture will run to completion.
		</para>
		<para>
			Running the test in the debugger is nice, but it should also be runnable without a debugger attached.
			Therefore, hit Ctrl+F5 to start without debugger. You should see the following output:
			<figure><title>Console Output</title>
				<graphic fileref="tut_run_console.png"></graphic>
			</figure>
			Note that this time, no breakpoint has been hit in the failing test case (Test2) -- instead, the failure
			is logged and execution is resumed. Note that when run in the debugger, cfix by default logs output to the
			Output Window<indexterm><primary>Output Window</primary></indexterm>. When run outside the debugger, 
			cfix logs output to the console. Of course, you can customize this
			behaviour by providing appropriate command line switches.
		</para>
		<para>
			This concludes the tutorial. Before beginning to write tests, have a look at the various command line switches 
			that can be used to customize the behaviour of cfix. The distribution also contains a Visual Studio sample project
			that may serve as a starting point for further steps.
		</para>
		<para>
			And finally, if you experience any problems with cfix, do not hesitate to contact me via passing at users.sourceforge.net.
		</para>
	</section>
  </chapter>
  <chapter id="API">
	<title>API</title>

	<section>
		<title>API for use in test cases</title>
		<para>
		Test cases, setup routines and teardown routines may use the following API.
		</para>
		
		<section>
			<title>CFIX_ASSERT</title>
			<para>
			Use CFIX_ASSERT to assert any expression. If the expression evaluates to be false, the test case is considered
			to have failed. The report for a Failed assertions includes the expression itself, file and line number as well
			as the function name. 
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_ASSERT( Expression )
			</programlisting>
			
			<para>
				Usage examples:
			</para>
			<programlisting>
CFIX_ASSERT( a == 1 );
CFIX_ASSERT( !"This will always fail" );
			</programlisting>
		</section>
		
		<section>
			<title>CFIX_ASSERT_EQUALS_DWORD</title>
			<para>
			CFIX_ASSERT_EQUALS_DWORD is similar to CFIX_ASSERT, but has the additional feature of reporting expected and actual
			value of the expressions compared.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_ASSERT_EQUALS_DWORD( Expected, Actual )
			</programlisting>
			
			<para>
				Usage examples:
			</para>
			<programlisting>
CFIX_ASSERT_EQUALS_DWORD( ERROR_FILE_NOT_FOUND, GetLastError() );
CFIX_ASSERT_EQUALS_DWORD( 42, foo );
			</programlisting>
		</section>

		<section>
			<title>CFIX_INCONCLUSIVE</title>
			<para>
			Whenever a test case cannot be executed properly and is thus inconclusive, use CFIX_INCONCLUSIVE to report
			the reason of inconclusiveness. The test case will be immediately aborted. Note that
			only Unicode strings are supported.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_INCONCLUSIVE( Message )
			</programlisting>
			
			<para>
				Usage examples:
			</para>
			<programlisting>
CFIX_INCONCLUSIVE( L"This test case cannot be run on WOW64" );
CFIX_INCONCLUSIVE( L"This test case requires administrative privileges" );
			</programlisting>
		</section>
		
		<section>
			<title>CFIX_LOG</title>
			<para>
			Use CFIX_LOG to log arbitrary information. The macro allows printf-style formatting and variable argument lists. Note that
			only Unicode strings are supported.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_LOG( Format, ... )
			</programlisting>
			
			<para>
				Usage examples:
			</para>
			<programlisting>
CFIX_LOG( L"A simple log message" );
CFIX_LOG( L"Value is %x, Last error was: %d", foo, GetLastError() );
			</programlisting>
		</section>
		
		<section>
			<title>CfixCreateThread</title>
			<para>
			Use CfixCreateThread whenever you need to create a thread from within a test case and this
			thread may use any of the APIs in this section. CfixCreateThread is a wrapper for
			CreateThread with the added functionality that the thread is registered so that
			cfix can properly relate any asserions etc. to the current test case.
			</para>
			<para>
			See MSDN for discussion of parameters and usage description.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIXAPI HANDLE CFIXCALLTYPE CfixCreateThread(
	__in PSECURITY_ATTRIBUTES ThreadAttributes,
	__in SIZE_T StackSize,
	__in PTHREAD_START_ROUTINE StartAddress,
	__in PVOID Parameter,
	__in DWORD CreationFlags,
	__in PDWORD ThreadId
	);
			</programlisting>
		</section>

	</section>
	<section>
		<title>Fixture definition</title>

		<para>
		Fixtures are defined with the following construct:
		<programlisting>
CFIX_BEGIN_FIXTURE( SuiteName )
	CFIX_FIXTURE_SETUP( Setup )
	CFIX_FIXTURE_TEARDOWN( Teardown )
	CFIX_FIXTURE_ENTRY( TestCae )
CFIX_END_FIXTURE()
		</programlisting>
		It is best to put this at the end of a file. 
		
		<note>
			The order of CFIX_FIXTURE_ENTRY, CFIX_FIXTURE_SETUP and 
			CFIX_FIXTURE_TEARDOWN is irrelevant. For the current release, 
			however, (1.0), the order of FIXTURE_ENTRYs defines the 
			execution order.
		</note>
		</para>
		
		<section>
			<title>CFIX_BEGIN_FIXTURE</title>
			<para>
			CFIX_BEGIN_FIXTURE defines the start of a fixture definition. It is also used to specify the name
			of the fixture.
			</para>
			<para>
			SuiteName defines the name of the fixture. It must be unique across
			all fixtures of the same test module (i.e. DLL). The same restrictions as for naming
			routines apply, i.e. no spaces, no special characters etc.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_BEGIN_FIXTURE( SuiteName )
			</programlisting>
			<note>Do not put quotes around the suite name.</note>
		</section>
		<section>
			<title>CFIX_END_FIXTURE</title>
			<para>
			CFIX_END_FIXTURE defines the end of a fixture definition. 
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_BEGIN_FIXTURE()
			</programlisting>
		</section>
		<section>
			<title>CFIX_FIXTURE_SETUP</title>
			<para>
			Used to define which routine is to be used as setup routine. Using CFIX_FIXTURE_SETUP
			is optional, however, it may not be used more than once per fixture definition.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_FIXTURE_SETUP( Routine )
			</programlisting>
			
			<para>
			Setup routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
			used as compiler switch.
			</para>
			<programlisting>
void __stdcall SetupRoutine()
			</programlisting>
		</section>
		<section>
			<title>CFIX_FIXTURE_TEARDOWN</title>
			<para>
			Used to define which routine is to be used as setup routine. Using CFIX_FIXTURE_TEARDOWN
			is optional, however, it may not be used more than once per fixture definition.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_FIXTURE_TEARDOWN( Routine )
			</programlisting>
			
			<para>
			Teardown routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
			used as compiler switch.
			</para>
			<programlisting>
void __stdcall TeardownRoutine()
			</programlisting>
		</section>
		<section>
			<title>CFIX_FIXTURE_ENTRY</title>
			<para>
			Used to add a test case to the fixture. CFIX_FIXTURE_ENTRY may be used any number of times per fixture.
			</para>
			
			<para>
				Declaration:
			</para>
			<programlisting>
CFIX_FIXTURE_ENTRY( Routine )
			</programlisting>
			
			<para>
			Test routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
			used as compiler switch.
			</para>
			<programlisting>
void __stdcall TestRoutine()
			</programlisting>
		</section>
	</section>
  </chapter>
  <!--
  Building 
   - IA64
  
  
  <chapter id="Usage">
	<title>Usage</title>

	<section>
		<title>Configuring test projects</title>
		<section>
			<title>Visual Studio</title>
		</section>
		<section>
			<title>WDK</title>
		</section>
	</section>
	<section>
		<title>Authoring tests</title>
		<section>
			<title>Fixture Definition</title>
		</section>
		<section>
			<title>Assertions</title>
		</section>
	</section>
	<section>
		<title>Running tests</title>
		<section>
			<title>Command line switches</title>
		</section>
		<section>
			<title>Debugging</title>
		</section>
	</section>
  </chapter>
	-->
  
</book>
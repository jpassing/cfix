<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
	<!ENTITY TestApiDefaultRequirements SYSTEM "book_api_req.xml">
	<!ENTITY TestDefDefaultRequirements SYSTEM "book_testdef_req.xml">
]>
<!--
	TODO
		- W2K as platform
		- driver unsigned
-->
<book >
  <title>cfix</title>

  <bookinfo>
    <releaseinfo>Release 1.1</releaseinfo>
    <author>Johannes Passing</author>
  </bookinfo>

  <toc/>

  <chapter id="Preface">
	<title>Preface</title>
	<section id="Legal">
		<title>Legal notice</title>
		<para>
		Copyright of this document 2007-2008 Johannes Passing. All rights reserved.
		</para>
		<para>
		Microsoft, Active Directory, ActiveMovie, ActiveX, BackOffice, ClearType, Developer Studio, Direct3D, Direct Animation, 
		DirectDraw, DirectInput, DirectMusic, DirectPlay, DirectShow, DirectSound, DirectX, IntelliMouse, JScript, Microsoft Press, 
		MSDN, MSN, MS-DOS, Natural, NetMeeting, NetShow, Sidewalk, Visual Basic, Visual C++, Visual C#, Visual FoxPro, Visual J++, 
		Visual Studio, WebTV, Win32, Win32s, Windows, Windows NT, and Windows Server are either registered trademarks or trademarks 
		of Microsoft Corporation in the United States and/or other countries.
		</para>
		<para>
		Java is a trademark of Sun Microsystems.
		</para>
		<para>
		Usage of this documentation is subject to the licensing terms of the GNU Lesser General Public License, version 3.0.
		</para>
	</section>
   </chapter>
   <chapter id="Background">
	<title>Background</title>
	<section id="BackgroundIntroduction">
		<title>Introduction</title>
		<para>
		cfix is a framework for authoring and running xUnit-like testcases written in C or C++. The aim of the tool
		is to provide a development experience very similar to frameworks such as JUnit or NUnit. Due to the nature of
		C and C++, current unit testing	frameworks for C and C++ hardly reach the ease of use of JUnit or NUnit. In 
		particular, it is noticable that significantly more code has to be written to implement a test suite. 
		</para>
		<para>
		Languages like Java and the various .Net languages, as well as scripting languages, all provide reflection facilities.
		Unit testing frameworks for these languages can therefore rely on reflective features in order to minimize the amount
		of code required to define a test suite. Provided a library, the framework can find and identify test cases and is able to selectively run them.
		</para>
		<para>
		Lacking similar reflective facilities, the route most unit testing frameworks for C and C++ have 
		chosen is to oblige the developer to explicitly define test cases and fixtures. Taking CUnit as an example,
		the developer has to make explictit function calls to define a test suite, add test cases to the suite and to 
		finally run this suite. CppUnit simplifies this a bit, but still requires the developer to implement quite
		some amount of initialization code. Another important drawback of this approach is the fact that no real
		separation between test code and test runner is done. Often, even the choice whether to use a graphical or a console frontend for 
		running test is tied to this initialization code.
		</para>
		<para>
		Based on this observation, it is clearly desirable to minimize the amount of boilerplate code the developer 
		has to write. Furthermore, a separation (in terms of artifacts, i.e. binaries) between the code to be tested
		and the test runner application is crucial.
		</para>
	</section>
	<section id="Portability">
		<title>Portability</title>
		<para>
		Most current unit testing frameworks for C and C++ are portable. The same tools can be used to test code on a multitude of
		platforms. Although a sound feature, several compromises have to be made to allow portability of both tools and test suites.
		As such, forgoing non-portable operating system features contributes to the fact that these frameworks are significantly
		less convenient to use than their managed counterparts NUnit or JUnit.
		</para>
		<para>
		For a vast amount of projects, portability is not actually required - a significant amount of software developed 
		today is targeted at a single platform only. Striving to provide a powerful, yet easy to use testing framework, the approach
		chosen by cfix is thus to sacrifice portability in order to gain the option to fully exploit the services provided
		by the Windows platform. These services at hand, cfix is thus able to provide the features expressed in the previous section -
		minimizing the amount of code a developer has to write and providing a strict separation in terms of artifacts 
		between test code and test runner.
		</para>
	</section>
	<section id="Terms">
		<title>Terms used</title>
		<para>
		The following terms are used throughout this documentation.
		</para>
		<section id="TermTestCase">
			<title>Test Case</title>
			<para>
				A Test Case<indexterm><primary>Test Case</primary></indexterm> contains the actual testing code. It utilizes assertions etc. to report
				success or failure of certain operations. A test case is implemented as a single routine.
			</para>
			<para>
				This understanding corresponds to test methods (i.e. methods decorated with [Test]) in NUnit.
			</para>
		</section>
		<section id="TermTestFixture">
			<title>Test Fixture</title>
			<para>
				A Test Fixture<indexterm><primary>Test Fixture</primary></indexterm> is a collection of test cases, accompanied by a setup and teardown routine.
			</para>
			<para>
				This understanding corresponds to test classes (i.e. classes decorated with [TestFixture]) in NUnit.
			</para>
		</section>
		<section id="TermTestModule">
			<title>Test Module</title>
			<para>
				All fixtures are compiled and linked into a single binary, which is a DLL file. This DLL file
				is referred to as Test Module<indexterm><primary>Test Module</primary></indexterm>.
			</para>
		</section>
		<section id="TermTestSuite">
			<title>Test Suite</title>
			<para>
				A collection of one or more test modules is referred to as test suite.
			</para>
		</section>
	</section>
	<section id="Strategy">
		<title>Tool strategy</title>
		<para>
		As indicated in the <link linkend="Introduction">Introduction</link>, cfix implements a separation between
		test code, which is provided in form of a test module, and the test runner, which is provided by cfix. This
		separation is similar to NUnit and JUnit, but differs significantly from the approach chosen by CUnit and CppUnit.
		</para>
		
		<para>
		All test cases and fixtures are compiled and linked into a simgle DLL, the test module. The test runner, named
		cfix32.exe (or cfix64.exe for AMD64 platfowms), can now be used to run all or a selection of test fixtures.
		The way cfix implements this introspection of a test module is to rely on the features of the PE file format
		used by Windows. By inspecting the export directory of the PE file, all fixtures defined in a test module can
		be identified. Depending on user input, cfix can then selectively run these fixtures. This approach is similar to WinUnit,
		although the exact implementation differs.
		</para>
	</section>
  </chapter>
  
  <chapter id="Usage">
	<title>Usage</title>
	<section id="Platforms">
		<title>Supported Platforms<indexterm><primary>Platforms</primary></indexterm></title>
		<para>
			<table frame="all"><title>Supported Platforms</title>
				<tgroup cols="4" align="left" colsep="1" rowsep="1">
					<thead>
						<row>
						  <entry></entry>
						  <entry>i386</entry>
						  <entry>AMD64</entry>
						  <entry>IA-64</entry>
						</row>
					</thead>
					<tbody>
						<row>
						  <entry>Windows Server 2008</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows Vista</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows Server 2003</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows XP</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows 2000</entry>
						  <entry>Supported</entry>
						  <entry>N/A</entry>
						  <entry>See remark [1]</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</para>
		
		<itemizedlist>
			<listitem>
				[1] Itanium: cfix <emphasis>should</emphasis> run on IA64. However, short of an Itanium machine, no tests have been performed on this platform and therefore, no binaries are provided. 
			</listitem>
		</itemizedlist>	
		
		<para>
			Older NT platforms (3.x, 4.0) as well as all consumer Windows releases (95, 98, ME) are not supported.
		</para>
	</section>
	<section id="TestRun">
		<title>Test Run<indexterm><primary>Test Run</primary></indexterm></title>
		<para>
		Provided one or more test modules, cfix can be requested to run certain fixtures<indexterm><primary>Fixture</primary></indexterm>. Fixtures
		are exeuted in the following sequence:
		
		<itemizedlist>
		<listitem>
			<para>
			First, the setup routine<indexterm><primary>Setup Routine</primary></indexterm> (if one has been provided) is run. In case
			an assertion fails or an unhandled exception is thrown from within the setup routine, the routine is aborted. As the 
			setup routine is considered to play a vital role for successful execution of a fixture, the entire fixture
			is aborted as well.
			</para>
		</listitem>
		<listitem>
			<para>
			Next, the test cases of the fixture are run one after another. In case of failed assertions or unhandled exceptions, the
			test case is immediately aborted and execution is resumed at the next test case.
			</para>
		</listitem>
		<listitem>
			<para>
			Finally, after all test cases have completed, the teardown routine is run. Teardown routines, like setup routines,
			are optional, so this step does not apply to all fixtures. Again, failed assertions and unhandled exceptions
			lead to the abortion of the routine.
			</para>
		</listitem>
		</itemizedlist>
		
		<note>
		Fixtures are always run	in their entirety -- it is not possible to run a single test case only.
		</note>
		
		What exactly does abortion of a routine mean? All failures are first reported so that the user is informed about the
		situation. By using Windows Structured Exception Handling, cfix then causes the affected routine to be aborted, i.e.
		no further statements of the routine are executed. 
		</para>
		<para>
		It is notable that the exact behaviour in the event of a failure differs on the context. As such, cfix is aware
		of the presence of a debugger and adapts its behaviour appropriately. As an example, if a debugger is present and an
		assertion fails, the test case is not aborted -- instead a brealpoint is issued so that the debugger breaks in
		on the affected line of code.
		</para>
		<para>
		Moreover, by specifying appropriate command line options, the behaviour can be further adjusted. This includes changing the way
		cfix deals with unhandled exceptions or specifying that the test run should be aborted as soon as the first failure
		occurs.
		</para>
		<para>
		As indicated before, all events -- be it the successful completion of a test case, failed assertions, log messages or 
		unhandled exceptions are reported. Depending on the options chosen by the user, the information
		is displayed on the console or logged to a text file.
		</para>
	</section>
	<section id="Multithreading">
		<title>Multithreading<indexterm><primary>Multithreading</primary></indexterm></title>
		<para>
		cfix has been implemented in a threadsafe manner. Furthermore, test cases are explicily allowed to make use
		of multithreading as long as they use the wrapper function CfixCreateThread rather than CreateThread.
		</para>
		<para>
		The motivation behind this is as follows. Although the current release supports execution of one fixture
		at a time only, future releases are planned to allow parallel test execution. While the details are not of
		importance at this stage, it already raises the question of how to deal with unknown threads, i.e. threads that
		have been created by test cases and are thus outside of cfix' control. In order to relate such threads
		to the test case they belong to, cfix needs some help -- and this help comes in the form of using
		the CfixCreateThread wrapper function. cfix will relate a thread created by CfixCreateThread with the 
		existing test case and is now also able to handle any events (assertions etc) by this thread properly.
		
		<note>
			When creating threads from within a test case and these threads use the cfix API (CFIX_ASSERT, CFIX_LOG etc), always
			make sure to use CfixCreateThread rather than CreateThread. Threads not using the cfix API (worker threads etc)
			are not affected by this requirement.
		</note>
		</para>
	</section>
	<section id="Building">
		<title>Building cfix<indexterm><primary>Building</primary></indexterm></title>
		<para>
			Under normal circumstances, it is advisable to use the binaries provided on the download page. 
			On the one hand, building cfix by yourself requires certain prerequisites to be met. On the other hand, 
			using the prebuilt binaries makes sure that in case of a problem with cfix, it is ensured that proper symbols exist 
			for debugging a crash dump.
		</para>
		<para>
			Building cfix requires the following software to be installed:
			<itemizedlist>
				<listitem>
					WDK 6000.
				</listitem>
				<listitem>
					Windows SDK 6.0. Note that due to the fact that build.exe is unable to handle include paths containing spaces, 
					the default installation directory (C:\Program Files\Microsoft SDKs\Windows\v6.0) cannot be used by build.exe. 
					Either install the SDK to a directory not containing spaces or create an appropriate link. 
					The environment variable SDKBASE should be set up to point to the SDK installation directory.
				</listitem>
				<listitem>
					DdkBuild. DdkBuild can be obtained from http://www.hollistech.com/Resources/ddkbuild/ddkbuild.htm.
				</listitem>
				<listitem>
					rcstamp. cfix currently uses rcstamp for versioning resources. rcstamp can be ontained at http://www.codeproject.com/KB/applications/rcstamp.aspx.
				</listitem>
			</itemizedlist>
			
			When these prereqisites have been met, you should be able to build cfix using nmake -f makefile.cfix.
		</para>
	</section>
  </chapter>
  
  <chapter id="TutorialUserVs">
    <title>Tutorial (User Mode)</title>
	<section id="TutorialUserVsInstallingCfix">
		<title>Post-installation steps</title>
		<para>
		After having installed cfix, you will see the following folder structure:
		<figure><title>Folder Structure<indexterm><primary>Folder Structure</primary></indexterm></title>
			<graphic fileref="tut_foldstruct.gif">
			</graphic>
		</figure>
		The bin folder contains the binaries, the ones of interest are cfix32<indexterm><primary>cfix32</primary></indexterm> 
		and cfix64<indexterm><primary>cfix64</primary></indexterm>. The binaries contain their
		bit-ness in their name so that you can put both the i386 and the amd64 folder in your 
		PATH<indexterm><primary>PATH</primary></indexterm> without getting
		conflicts. The remaining folders should be self-explanatory.
		</para>
		<para>
		The tutorial assumes that you plan to write tests with Visual Studio<indexterm><primary>Visual Studio</primary></indexterm>. 
		In this case, it is advisable to first configure
		Visual Studio so that it automatically finds the required cfix files. The following paragraphs explain how.
		</para>
		<para>
		Start Visual Studio and open the Options dialog<indexterm><primary>Options Dialog</primary></indexterm> (Tools | Options). 
		In the tree view on the left, navigate to
		'Projects and Solutions' and finally 'C++ Directories'<indexterm><primary>C++ Directories</primary></indexterm>. There, 
		add the appropriate cfix binary directories (bin\i386 for platform 'Win32', bin\amd64 for platform 'x64').
		<figure><title>Configuring Exe Directories</title>
			<graphic fileref="tut_vs_opt_exe.gif">
			</graphic>
		</figure>
		
		<note>
		Rather than using absolute paths, you can use the $(CFIX_HOME) environment variable the installer sets by default.
		That is, use $(CFIX_HOME)\include, $(CFIX_HOME)\lib\i386 and $(CFIX_HOME)\bin\i386 to refer to the cfix include, library,
		and  binary directory,respectively.
		</note>
		
		Now, select 'Include files'<indexterm><primary>Include files</primary></indexterm> in the dropdown menu on the 
		top right and add the cfix include directory to the list.
		<figure><title>Configuring Include Directories</title>
			<graphic fileref="tut_vs_opt_inc.gif">
			</graphic>
		</figure>
		
		And finally, select 'Library files'<indexterm><primary>Library files</primary></indexterm> in the dropdown menu on the top right 
		and add add the appropriate 
		cfix library directories (lib\i386 for platform 'Win32', lib\amd64 for platform 'x64').
		<figure><title>Configuring Library Directories</title>
			<graphic fileref="tut_vs_opt_lib.gif">
			</graphic>
		</figure>
		
		That is all, we are ready to write our first test project.
		</para>
	</section>
	<section id="TutorialUserVsAuthoringATestSuite">
		<title>Authoring a test suite</title>
		<para>
		Test Modules are DLLs, so we need to create a new DLL project. In the 'New Project' Wizard, select 
		'Win32 Project'. On the following page, choose 'DLL' as application type.
		<figure><title>Creating a new Project</title>
			<graphic fileref="tut_vs_newproj.png">
			</graphic>
		</figure>
		</para>
		<para>
		A minimalistic test project could consist of the following code:
		<programlisting>
#include "stdafx.h"
#include &lt;cfix.h&gt;

/*++
	Routine Description:
		Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
	int a = 1;
	int b = 1;
	CFIX_ASSERT( a + b == 2 );
}

CFIX_BEGIN_FIXTURE( MyMinimalisticFixture )
	CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
		</para>
		<para>
		But let us look at a more interesting example. Open a source file and copy the following code:
			<programlisting>
//
// Always include cfix.h!
//
#include "stdafx.h"
#include &lt;cfix.h&gt;

/*++
  Routine Description:
    Setup Routine -- will be called at the very beginning of the
    testrun. If the setup routine fails, no testcase of this 
    fixture will be executed.

    If your default calling convention is cdecl (this is the 
    case for Visual Studio projects), be sure to add __stdcall 
    to all routine decarations -- otheriwse you will get the 
    following warning:
       cannot convert from 'void (__cdecl *)(void)' 
       to 'CFIX_PE_TESTCASE_ROUTINE'

    As the routine is referenced only by the fixture definition 
    (see below), you may declare this routine as static.
--*/
static void __stdcall FixtureSetup()
{
  CFIX_ASSERT( 0 != 1 );
}

/*++
  Routine Description:
    Teardown Routine -- will be called at the end of the
    testrun. 
--*/
static void __stdcall FixtureTeardown()
{
  CFIX_LOG( L"Tearing down..." );
}

/*++
  Routine Description:
    Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
  DWORD a = 1;
  DWORD b = 1;
  CFIX_ASSERT_EQUALS_DWORD( a, b );
  CFIX_ASSERT( a + b == 2 );

  //
  // Log a message -- printf-style formatting may be used.
  //
  CFIX_LOG( L"a=%d, b=%d", a, b );
}

/*++
  Routine Description:
    Another test routine -- one that will trigger a failed 
    assertion.
--*/
static void __stdcall Test2()
{
  DWORD a = 17;

  //
  // This one will fail. If run in the debugger, it will break here.
  // if run outside the debugger, the failure will be logged and the
  // testcase is aborted.
  //
  CFIX_ASSERT( a == 42 );
}

/*++
  Description:
    These lines define a test fixture. It is best to put this at the
    end of the file.

    'MyFixture' is the name of the fixture. It must be unique across
    all fixtures of this DLL. The same restrictions as for naming
    routines apply, i.e. no spaces, no special characters etc.

    The order of CFIX_FIXTURE_ENTRY, CFIX_FIXTURE_SETUP and 
    CFIX_FIXTURE_TEARDOWN is irrelevant. For the current release, 
    however, (1.0), the order of FIXTURE_ENTRYs defines the 
    execution order.
--*/
CFIX_BEGIN_FIXTURE( MyFixture )
  //
  // Define Test1 and Test2 to be test routines. You can define any 
  // number of test routines.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
  CFIX_FIXTURE_ENTRY( Test2 )

  //
  // Define FixtureSetup to be a setup routine. At most one
  // CFIX_FIXTURE_SETUP line may be declared per fixture.  If the
  // fixture does not require setup, omit this line.
  //
  CFIX_FIXTURE_SETUP( FixtureSetup )

  //
  // Define FixtureTeardown to be a teardown routine. As with
  // setup routines, you can declare at most one such routine
  // per fixture. If the fixture does not require teardown, 
  // omit this line.
  //
  CFIX_FIXTURE_TEARDOWN( FixtureTeardown )
CFIX_END_FIXTURE()

CFIX_BEGIN_FIXTURE( MyOtherFixture )
  //
  // You are free to reuse certain routines in another fixture if
  // it makes sense.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
			In order to run the code in the debugger, we have to make some adaptions to the project configuration
			<indexterm><primary>Project Configuration</primary></indexterm>.
			Open the project's property page and navigate to the 'Debugging'<indexterm><primary>Debugging</primary></indexterm> node. There, add
			'cfix32.exe' (or 'cfix64.exe' for the x64 configuration) as Command<indexterm><primary>Command</primary></indexterm>. Of course, this
			requires that you have previously set up the directories in the options dialog, 
			as described previously. (And do not omit the .exe suffix -- otherwise running without
			debugger will not work).
			<figure><title>Adjusting Debugging Settings</title>
				<graphic fileref="tut_vs_projsettings.png"></graphic>
			</figure>
		</para>
		<para>
			As Command Arguments<indexterm><primary>Command Arguments</primary></indexterm>, type -u "$(OutDir)\$(ProjectName).dll".
			I have used the -u switch in order to break on exceptions. This makes debugging easier, so
			it is advisable to always use this switch for debugging.
			<note>When using C++<indexterm><primary>C++</primary></indexterm>, you shoud use the compiler switch
			/EHa<indexterm><primary>/EHa</primary></indexterm> rather than /EHs<indexterm><primary>/EHs</primary></indexterm>. 
			cfix internally uses SEH<indexterm><primary>SEH</primary></indexterm> and using
			/EHa ensures that your destructors are called properly in case a test case is aborted.
			</note>
		</para>
	</section>
	<section id="TutorialUserVsRunningTheTest">
		<title>Running the test</title>
		<para>
			Hit F5 to compile the project and launch the test. Soon after the tesrun has started, you should see the following
			dialog indicating that a breakpoint<indexterm><primary>Breakpoint</primary></indexterm> has been hit:
			<figure><title>Failed Assertion</title>
				<graphic fileref="tut_vs_break.gif"></graphic>
			</figure>
			Click 'break' and you will see that the current the statement CFIX_ASSERT( a == 42 ) has fired --
			which is not surprising as a has the value 17. Now open the output window (Ctrl+Alt+O) and you should
			see the following output:
			<figure><title>Output Window</title>
				<graphic fileref="tut_run_dbg.png"></graphic>
			</figure>
			If you want to ignore this assertion, hit F5 and the fixture will run to completion.
		</para>
		<para>
			Running the test in the debugger is nice, but it should also be runnable without a debugger attached.
			Therefore, hit Ctrl+F5 to start without debugger. You should see the following output:
			<figure><title>Console Output</title>
				<graphic fileref="tut_run_console.png"></graphic>
			</figure>
			Note that this time, no breakpoint has been hit in the failing test case (Test2) -- instead, the failure
			is logged and execution is resumed. Note that when run in the debugger, cfix by default logs output to the
			Output Window<indexterm><primary>Output Window</primary></indexterm>. When run outside the debugger, 
			cfix logs output to the console. Of course, you can customize this
			behaviour by providing appropriate command line switches.
		</para>
		<para>
			This concludes the tutorial. Before beginning to write tests, have a look at the various command line switches 
			that can be used to customize the behaviour of cfix. The distribution also contains a Visual Studio sample project
			that may serve as a starting point for further steps.
		</para>
		<para>
			And finally, if you experience any problems with cfix, do not hesitate to ask!
		</para>
	</section>
  </chapter>
  <chapter id="TutorialKernelWdk">
    <title>Tutorial (Kernel Mode)</title>
	<section id="TutorialKernelWdkInstallingCfix">
		<title>Post-installation steps</title>
		<indexterm><primary>WDK</primary></indexterm>
		<indexterm><primary>CFIX_HOME</primary></indexterm>
		<indexterm><primary>INCLUDE</primary></indexterm>
		<indexterm><primary>LIB</primary></indexterm>
		<para>
		After having installed cfix, you will see the following folder structure:
		<figure><title>Folder Structure<indexterm><primary>Folder Structure</primary></indexterm></title>
			<graphic fileref="tut_foldstruct.gif">
			</graphic>
		</figure>
		The bin folder contains the binaries, the ones of interest are cfix32<indexterm><primary>cfix32</primary></indexterm> 
		and cfix64<indexterm><primary>cfix64</primary></indexterm>. The binaries contain their
		bit-ness in their name so that you can put both the i386 and the amd64 folder in your 
		PATH<indexterm><primary>PATH</primary></indexterm> without getting
		conflicts. The remaining folders should be self-explanatory. 
		</para>
		<para>
		<indexterm><primary>Windows Driver Kit</primary></indexterm> 
		<indexterm><primary>WDK</primary></indexterm> 
		
		Like drivers, kernel mode unit tests are built using the Windows Driver Kit (WDK). The tutorial therefore assumes 
		that you have installed a recent version of the WDK, i.e. WDK 6000 or newer.
		</para>
		<para>
		In your SOURCES files, you will have to refer to the cfix header and library files. The easiest way to do
		this is to leverage the CFIX_HOME environment variable the installer sets by default: Use 
		$(CFIX_HOME)\include to refer to the cfix include directory, and $(CFIX_HOME)\lib\$(TARGET_DIRECTORY)
		to refer to the library directory.
		</para>
		<para>
		In any case, bear in mind that build.exe is unable to work with include paths that use spaces.
		</para>
	</section>
	<section id="TutorialKernelWdkAuthoringATestSuite">
		<title>Authoring a test suite</title>
		<indexterm><primary>CFIX_KERNELMODE</primary></indexterm>
		<para>
		Having installed cfix, we can now write a first test. The source code of a kernel mode
		unit test is identical to user mode tests, so we can use the same samples as supplied
		in the user mode tutorial (The only differences are that ULONGs are used rather than DWORDs
		and stdafx.h has been removed). A minimalistic test project could thus consist of the following code:
		<programlisting>
#include &lt;cfix.h&gt;

/*++
	Routine Description:
		Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
	int a = 1;
	int b = 1;
	CFIX_ASSERT( a + b == 2 );
}

CFIX_BEGIN_FIXTURE( MyMinimalisticFixture )
	CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
		</para>
		<para>
		But let us look at a more interesting example like the following:
			<programlisting>
//
// Always include cfix.h!
//
#include &lt;cfix.h&gt;

/*++
  Routine Description:
    Setup Routine -- will be called at the very beginning of the
    testrun. If the setup routine fails, no testcase of this 
    fixture will be executed.
	
    As WDK projects use __stdcall by default, there is usually
    no need to explicitly specify __stdcall on your routines.
	
    As the routine is referenced only by the fixture definition 
    (see below), you may declare this routine as static.
--*/
static void FixtureSetup()
{
  CFIX_ASSERT( 0 != 1 );
}

/*++
  Routine Description:
    Teardown Routine -- will be called at the end of the
    testrun. 
--*/
static void FixtureTeardown()
{
  CFIX_LOG( L"Tearing down..." );
}

/*++
  Routine Description:
    Test routine -- do the actual testing.
--*/
static void Test1()
{
  ULONG a = 1;
  ULONG b = 1;
  CFIX_ASSERT_EQUALS_ULONG( a, b );
  CFIX_ASSERT( a + b == 2 );

  //
  // Log a message -- printf-style formatting may be used.
  //
  CFIX_LOG( L"a=%d, b=%d", a, b );
}

/*++
  Routine Description:
    Another test routine -- one that will trigger a failed 
    assertion.
--*/
static void Test2()
{
  ULONG a = 17;

  //
  // This one will fail. If run in the debugger, it will break here.
  // if run outside the debugger, the failure will be logged and the
  // testcase is aborted.
  //
  CFIX_ASSERT( a == 42 );
}

/*++
  Description:
    These lines define a test fixture. It is best to put this at the
    end of the file.

    'MyFixture' is the name of the fixture. It must be unique across
    all fixtures of this driver. The same restrictions as for naming
    routines apply, i.e. no spaces, no special characters etc.

    The order of CFIX_FIXTURE_ENTRY, CFIX_FIXTURE_SETUP and 
    CFIX_FIXTURE_TEARDOWN is irrelevant. For the current release, 
    however, (1.1), the order of FIXTURE_ENTRYs defines the 
    execution order.
--*/
CFIX_BEGIN_FIXTURE( MyFixture )
  //
  // Define Test1 and Test2 to be test routines. You can define any 
  // number of test routines.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
  CFIX_FIXTURE_ENTRY( Test2 )

  //
  // Define FixtureSetup to be a setup routine. At most one
  // CFIX_FIXTURE_SETUP line may be declared per fixture.  If the
  // fixture does not require setup, omit this line.
  //
  CFIX_FIXTURE_SETUP( FixtureSetup )

  //
  // Define FixtureTeardown to be a teardown routine. As with
  // setup routines, you can declare at most one such routine
  // per fixture. If the fixture does not require teardown, 
  // omit this line.
  //
  CFIX_FIXTURE_TEARDOWN( FixtureTeardown )
CFIX_END_FIXTURE()

CFIX_BEGIN_FIXTURE( MyOtherFixture )
  //
  // You are free to reuse certain routines in another fixture if
  // it makes sense.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
		</para>
		<para>
			As usual for WDK projects, we have to supply a SOURCES file. Assuming you have
			saved your test code to a file named test.c, the SOURCES file should look as follows:
			<programlisting>
INCLUDES=$(CFIX_HOME)\include;$(DDK_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX /Wp64

#
# It is essential that CFIX_KERNELMODE is defined here!
#
USER_C_FLAGS=/DCFIX_KERNELMODE


#
# Link against cfixkdrv.lib and aux_klib.lib.
#
TARGETLIBS=\
  $(DDK_LIB_PATH)\aux_klib.lib \
  $(CFIX_HOME)\bin\$(TARGET_DIRECTORY)\cfixkdrv.lib

TARGETNAME=ktest
TARGETPATH=bin\$(DDKBUILDENV)
TARGETTYPE=DRIVER
SOURCES=test.c
			</programlisting>
			As the comments in the file suggest, two things are of importance. First you have to
			include /DCFIX_KERNELMODE in USER_C_FLAGS. If you forget to define CFIX_KERNELMODE,
			the cfix headers will assume you are building a user mode test project and will, 
			for example, try to bring in windows.h -- which, of course, will be inappropriate for
			a kernel mode test.
		</para>
		<para>
			Secondly, you have to link against cfixkdrv.lib. This library includes the stub routines
			for the cfix API. Moreover, this library includes an implementation of DriverEntry, which
			will turn your test project into a full-fledged driver.
		</para>
		<para>
			Moreover, you have to link agains aux_klib.lib, which is provided by the WDK. 
			However, note that WDK 6000 includes aux_klib.lib for WLH only. Yet, you can use it for 
			WXP/WNET as well - you just have to adapt your paths or copy the library from the WLH
			directory to the &lt;WDK&gt;\lib\WXP\&lt;arch&gt; and &lt;WDK>\lib\WLH\&lt;arch&gt; directories.
		</para>
		<para>
			One file is still missing -- the export definition file. Create a file named ktest.def
			(assuming that you used TARGETNAME=ktest) and add a single line:
			<programlisting>
EXPORTS
			</programlisting>
		</para>
		<para>
			That's it. Open a WDK command promot with the a build environment of choice and 
			create the test driver by running build.exe. This will result in 
			bin\chk\i386\ktest.sys to be created.
		</para>
	</section>	
	<section id="TutorialKernelWdkRunningTheTest">
		<title>Running the test</title>
		<indexterm><primary>WOW64</primary></indexterm>
		<indexterm><primary>-kern</primary></indexterm>
		<indexterm><primary>Bugcheck</primary></indexterm>
		<indexterm><primary>IRQL</primary></indexterm>
		<para>
			<warning>
				It should go without saying that you should never run test cases on your 
				development machine or on production machines -- always run tests on dedicated 
				test machines. The tests are run in kernel mode and can therefore crash your machine.
			</warning>
		</para>
			
		<para>
		Running kernel mode unit tests is no different than running user mode tests. That is, tests are
		run using the testrunner cfix32.exe (for 32 bit code) or cfix64.exe (for 64 bit code) .
		</para>
		
		<para>
		Note that a 64 bit test driver can be run either with cfix64.exe or with cfix32.exe, i.e. cfix
		is aware of WOW64 and the possibility that the kernel uses another bitness than the user mode
		test runner. Still, using cfix64.exe is preferrable in such cases.
		</para>
		
		<note>
		For obvious reasons, the cfix driver (cfixkr.sys) is not signed. On Vista x64 and Server 2008 x64,
		the driver thus will not be able to load unless the test system has been booted in debug mode
		or with Kernel Mode Code Signing disabled.
		</note>
		
		<para>
		Copy the test driver to your test machine (as always, drivers must be loaded from the local disk,
		so any attempt to load the test driver over the network will fail). Having done that, you can
		run cfix32.exe -kern -d ktest.sys to display the tests contained in the driver:
		<programlisting>
C:\drv\i386>cfix32 -kern -d ktest.sys
Cfix version 1.1.3059.65 (chk)
(c) 2008 - Johannes Passing - http://cfix.sf.net/
Module: ktest (ktest.sys)
  Fixture: MyFixture
    Test1
    Test2

  Fixture: MyOtherFixture
    Test1
		</programlisting>
		</para>
		
		<para>
		Note that we have used the -kern switch. To avoid using kernel mode features accidently,
		the -kern switch is always necessary if you intend to use kernel mode features.
		</para>
		
		<para>
		That said, we can now run the test by executing cfix32.exe -kern ktest.sys. Assuming no
		kernel debugger has been attached, the following output will appear on your console:
		<programlisting>
C:\drv\i386>cfix32 -kern ktest.sys
Cfix version 1.1.3059.65 (chk)
(c) 2008 - Johannes Passing - http://cfix.sf.net/
[Log]          ktest.MyFixture.Test1
                 a=1, b=1

[Success]      ktest.MyFixture.Test1
[Failure]      ktest.MyFixture.Test2
                 d:\dev\wdev\cfix\doc\samples\temp\test.c(65): Test2

                 Expression: a == 42
                 Last Error: 0 (The operation completed successfully. )



[Log]          ktest.MyFixture.unknown
                 Tearing down...

[Log]          ktest.MyOtherFixture.Test1
                 a=1, b=1

[Success]      ktest.MyOtherFixture.Test1
		</programlisting>
		</para>
		
		<para>
		As is the case with user mode tests, cfix will detect if a kernel debugger is attached
		and will adapt its behaviour, i.e. it will issue a breakpoint when an assertion has failed.
		</para>
		
		<para>
		So let's run the command cfix32.exe -kern ktest.sys again on a machine that has a kernel debugger 
		attched. Test1 passes, so the following output appears on the console first:
		<programlisting>
C:\drv\i386>cfix32 -kern ktest.sys
Cfix version 1.1.3059.65 (chk)
(c) 2008 - Johannes Passing - http://cfix.sf.net/
[Log]          ktest.MyFixture.Test1
                 a=1, b=1

[Success]      ktest.MyFixture.Test1
		</programlisting>
		
		Test2, however, fails and causes a debugger breakin. WinDBG will report
		<programlisting>
Break instruction exception - code 80000003 (first chance)
ktest!Test2+0x2e:
f9fc50fe cc              int     3
		</programlisting>
		and the source window will show the culprit:
		<figure><title>WinDBG Source Window</title>
			<graphic fileref="tut_ktest_breakin.png">
			</graphic>
		</figure>
		
		Hiting F5 will continue the test (the same rules apply as in user mode testing) and
		the rest of the output will appear on the console:
		<programlisting>
[Failure]      ktest.MyFixture.Test2
                 d:\dev\wdev\cfix\doc\samples\temp\test.c(65): Test2

                 Expression: a == 42
                 Last Error: 0 (The operation completed successfully. )



[Log]          ktest.MyFixture.unknown
                 Tearing down...

[Log]          ktest.MyOtherFixture.Test1
                 a=1, b=1

[Success]      ktest.MyOtherFixture.Test1
		</programlisting>
		</para>
		
		<para>
			Some final words on kernel mode testing: cfix kernel mode tests are always initialted
			at PASSIVE_LEVEL. However, testcases are free to raise the IRQL to any level and still
			call CFIX_ASSERT etc. 
		</para>
		<para>
			Moreover, the cfix API (i.e. ASSERT etc) may only be used on the same
			thread. If called from a different thread, cfix will be unable to relate the call to a testrun -- after
			all, multiple kernel mode testruns could be run in parallel. Therefore, cfix will issue a warning
			via DbgPrint but will otherwise ignore these calls.
		</para>
		<para>
			Finally, cfix will catch and report any exceptions that your test code has raised and failed
			to handle. However, if your code causes a bugcheck, cfix will not be able to prevent that.
		</para>
	</section>
  </chapter>
  <chapter id="API">
	<title>API</title>

	
	<section id="TestAPI">
		<title>API for use in test cases</title>
		<para>
		Test cases, setup routines and teardown routines may use the following API.
		</para>
		
		<section id="CFIX_ASSERT">
			<title>CFIX_ASSERT</title>
			<indexterm><primary>CFIX_ASSERT</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Use CFIX_ASSERT to assert any expression. If the expression evaluates to be false, the test case is considered
				to have failed. The report for a Failed assertions includes the expression itself, file and line number as well
				as the function name. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting>
CFIX_ASSERT( Expression )
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting>
CFIX_ASSERT( a == 1 );
CFIX_ASSERT( !"This will always fail" );
				</programlisting>
			</simplesect>
			
			&TestApiDefaultRequirements;
		</section>
		
		<section id="CFIX_ASSERT_EQUALS_DWORD">
			<title>CFIX_ASSERT_EQUALS_DWORD, CFIX_ASSERT_EQUALS_ULONG</title>
			<indexterm><primary>CFIX_ASSERT_EQUALS_DWORD</primary></indexterm>
			<indexterm><primary>CFIX_ASSERT_EQUALS_ULONG</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIX_ASSERT_EQUALS_DWORD is similar to CFIX_ASSERT, but has the additional feature of reporting expected and actual
				value of the expressions compared. CFIX_ASSERT_EQUALS_ULONG is a synonym for CFIX_ASSERT_EQUALS_DWORD.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting>
CFIX_ASSERT_EQUALS_DWORD( Expected, Actual )
CFIX_ASSERT_EQUALS_ULONG( Expected, Actual )
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				<programlisting>
CFIX_ASSERT_EQUALS_DWORD( ERROR_FILE_NOT_FOUND, GetLastError() );
CFIX_ASSERT_EQUALS_ULONG( 42, foo );
				</programlisting>
			</simplesect>
			
			&TestApiDefaultRequirements;
		</section>

		<section id="CFIX_INCONCLUSIVE">
			<title>CFIX_INCONCLUSIVE</title>
			<indexterm><primary>CFIX_INCONCLUSIVE</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Whenever a test case cannot be executed properly and is thus inconclusive, use CFIX_INCONCLUSIVE to report
				the reason of inconclusiveness. The test case will be immediately aborted. Note that
				only Unicode strings are supported.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting>
CFIX_INCONCLUSIVE( Message )
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				
				<programlisting>
CFIX_INCONCLUSIVE( L"This test case cannot be run on WOW64" );
CFIX_INCONCLUSIVE( L"This test case requires admin privileges" );
				</programlisting>
			</simplesect>
			
			&TestApiDefaultRequirements;
		</section>
		
		<section id="CFIX_LOG">
			<title>CFIX_LOG</title>
			<indexterm><primary>CFIX_LOG</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Use CFIX_LOG to log arbitrary information. The macro allows printf-style formatting and variable argument lists. Note that
				only Unicode strings are supported.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting>
CFIX_LOG( Format, ... )
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				
				<programlisting>
CFIX_LOG( L"A simple log message" );
CFIX_LOG( L"Value is %x, Last error was: %d", foo, GetLastError() );
				</programlisting>
			</simplesect>
			
			&TestApiDefaultRequirements;
		</section>
		
		<section id="CfixCreateThread">
			<title>CfixCreateThread</title>
			<indexterm><primary>CfixCreateThread</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Use CfixCreateThread whenever you need to create a thread from within a test case and this
				thread may use any of the APIs in this section. CfixCreateThread is a wrapper for
				CreateThread with the added functionality that the thread is registered so that
				cfix can properly relate any asserions etc. to the current test case.
				</para>
				<para>
				See MSDN for discussion of parameters and usage description.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting>
CFIXAPI HANDLE CFIXCALLTYPE CfixCreateThread(
	__in PSECURITY_ATTRIBUTES ThreadAttributes,
	__in SIZE_T StackSize,
	__in PTHREAD_START_ROUTINE StartAddress,
	__in_opt PVOID Parameter,
	__in DWORD CreationFlags,
	__out_opt PDWORD ThreadId
	);
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Requirements</title>
		
				<table frame="all" tocentry="0">
					<tgroup cols="4" align="left" colsep="1" rowsep="1">
						<thead>
							<row>
							  <entry></entry>
							  <entry>User Mode</entry>
							  <entry>Kernel Mode</entry>
							</row>
						</thead>
						<tbody>
							<row>
							  <entry>Available since</entry>
							  <entry>1.0</entry>
							  <entry>Not supported</entry>
							</row>
							<row>
							  <entry>Header</entry>
							  <entry>Declared in cfix.h</entry>
							  <entry>Not supported</entry>
							</row>
							<row>
							  <entry>Library</entry>
							  <entry>Link to cfix.lib</entry>
							  <entry>Not supported</entry>
							</row>
							<row>
							  <entry>DLL</entry>
							  <entry>cfix.dll</entry>
							  <entry>N/A</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</simplesect>
		</section>


	</section>
	<section id="FixtureDefAPI">
		<title>Fixture definition</title>

		<para>
		Fixtures are defined with the following construct:
		<programlisting>
CFIX_BEGIN_FIXTURE( SuiteName )
	CFIX_FIXTURE_SETUP( Setup )
	CFIX_FIXTURE_TEARDOWN( Teardown )
	CFIX_FIXTURE_ENTRY( TestCae )
CFIX_END_FIXTURE()
		</programlisting>
		It is best to put this at the end of a file. 
		
		<note>
			The order of CFIX_FIXTURE_ENTRY, CFIX_FIXTURE_SETUP and 
			CFIX_FIXTURE_TEARDOWN is irrelevant. For the current release, 
			however, (1.0), the order of FIXTURE_ENTRYs defines the 
			execution order.
		</note>
		</para>
		
		<section id="CFIX_BEGIN_FIXTURE">
			<title>CFIX_BEGIN_FIXTURE</title>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIX_BEGIN_FIXTURE defines the start of a fixture definition. It is also used to specify the name
				of the fixture.
				</para>
				<para>
				SuiteName defines the name of the fixture. It must be unique across
				all fixtures of the same test module (i.e. DLL). The same restrictions as for naming
				routines apply, i.e. no spaces, no special characters etc.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting>
CFIX_BEGIN_FIXTURE( SuiteName )
				</programlisting>
				<note>Do not put quotes around the suite name.</note>
			</simplesect>
			
			&TestDefDefaultRequirements;
		</section>
		
		<section id="CFIX_END_FIXTURE">
			<title>CFIX_END_FIXTURE</title>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIX_END_FIXTURE defines the end of a fixture definition. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting>
CFIX_BEGIN_FIXTURE()
				</programlisting>
			</simplesect>
			
			&TestDefDefaultRequirements;
		</section>
		
		<section id="CFIX_FIXTURE_SETUP">
			<title>CFIX_FIXTURE_SETUP</title>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to define which routine is to be used as setup routine. Using CFIX_FIXTURE_SETUP
				is optional, however, it may not be used more than once per fixture definition.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting>
CFIX_FIXTURE_SETUP( Routine )
				</programlisting>
				<para>
				Setup routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting>
void __stdcall SetupRoutine()
				</programlisting>
			</simplesect>
			
			&TestDefDefaultRequirements;
		</section>
		
		<section id="CFIX_FIXTURE_TEARDOWN">
			<title>CFIX_FIXTURE_TEARDOWN</title>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to define which routine is to be used as setup routine. Using CFIX_FIXTURE_TEARDOWN
				is optional, however, it may not be used more than once per fixture definition.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting>
CFIX_FIXTURE_TEARDOWN( Routine )
				</programlisting>
				
				<para>
				Teardown routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting>
void __stdcall TeardownRoutine()
				</programlisting>
			</simplesect>
			
			&TestDefDefaultRequirements;
		</section>
		
		<section id="CFIX_FIXTURE_ENTRY">
			<title>CFIX_FIXTURE_ENTRY</title>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to add a test case to the fixture. CFIX_FIXTURE_ENTRY may be used any number of times per fixture.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting>
CFIX_FIXTURE_ENTRY( Routine )
				</programlisting>
				
				<para>
				Test routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting>
void __stdcall TestRoutine()
				</programlisting>
			</simplesect>
			
			&TestDefDefaultRequirements;
		</section>
	</section>
	<section id="APIComaptbility">
		<title>Note on compatibility and API stability</title>
		<para>
			All routines, data structures and macros documented as part of this documentation set are stable -- future relases of
			cfix will retain both binary and source level compatibility.
		</para>
		<para>
			Any routines, data structures and macros not mentioned in this documentation set are subject to change in future
			releases. Please restrict your usage of the cfix API to the documented subset. If any functionality
			should be missing, please report to passing at users.sourceforge.net.
		</para>
	</section>
  </chapter>
</book>